LamG (IteG EmptyG EmptyG EmptyG)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b
  then (b , true)
  else (b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun b ->
  if f b = b
  then (b , true)
  else (f b , false)
fun x ->
  if f x = b
  then (b , true)
  else (f x , false)
fun n ->
  if n < 10
  then 0
  else (let x = myHelper n in
        1 + additivePersistence x)
fun n ->
  if n < 10
  then 0
  else (let x = myHelper n in
        1 + additivePersistence x)
fun n ->
  if n < 10 then n else helper n
fun n ->
  if n <= 0
  then []
  else (let modded = n mod 10 in
        let quotient = n / 10 in
        let head =
          digitsOfInt quotient in
        head @ [modded])
fun n ->
  if n < 10
  then n
  else additivePersistence (sumList (digitsOfInt n))
fun b' ->
  if f b' = b'
  then (f b' , false)
  else (f b' , true)
fun b' ->
  if f b' = b'
  then (f b' , false)
  else (f b' , true)
fun b' ->
  if f b' = b'
  then (f b' , false)
  else (f b' , true)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
fun l ->
  if l = []
  then []
  else (let h :: t = l in
        match h with
        | 0 -> removeZero t
        | _ -> l)
