\subsection{Qualitative Evaluation}
\label{sec:qualitative}

Next, we present a \emph{qualitative} evaluation that compares the
predictions made by our classifiers with those of \sherrloc.
%
In particular, we demonstrate, with a series of example programs from
our student dataset, how our classifiers are able to use past student
mistakes to make more accurate predictions of future fixes.
%
For each example, we provide
%
(1) the code,
%
(2) \sherrloc's prediction (in \textbf{bold}), and
%
(3) the prediction of our Decision Tree (\underline{underlined}).
%
We choose the Decision Tree classifier for this section as its model
is more easily interpreted than the MLP.
%
We will also attempt, for each program, to explain \emph{why} the
Decision Tree made its prediction, by analyzing the paths induced
by the programs.

\paragraph{Extracting the Digits of an Integer}
% data/sp14/1655.ml
Our first program is a simple recursive function |digitsOfInt| that
extracts the digits of an |int|.
%
\begin{ecode}
  let rec digitsOfInt n =
    if n <= 0 then
      []
    else
      [n mod 10] @ __[ ___=digitsOfInt (n / 10)=___ ]__
\end{ecode}
%
Unfortunately, the student has decided to wrap the recursive call to
|digitsOfInt| with a list literal, even though |digitsOfInt| already
returns an |int list|.
%
Thus, the list literal is inferred to have type |int list list|, which
is incompatible with the |int list| on the left of the |@| (list append)
operator.
%
Both \sherrloc and the \ocaml compiler blame the recursive call for
returning a |int list| rather than |int|, but the recursive call is
actually correct!
%
As our Decision Tree correctly points out, the fault lies with the list
literal \emph{surrounding} the recursive call, remove it and the type
error disappears.
%
\ES{TODO: WHY?}

\paragraph{Padding a list}
% data/sp14/0306.ml
Our next program, |padZero|, is given two |int list|s as input, and must
left-pad the shorter one with enough zeros that the two output lists
have equal length.

The student first defines a helper function |clone|, which takes an
input element |x| and an |int| |n|, and returns a list containing |n|
|x|s.
%
\begin{ecode}
  let rec clone x n =
    if n <= 0 then
      []
    else
      x :: clone x (n - 1)
\end{ecode}
%
Then she defines |padZero| with a simple branch that determines which
list is shorter, followed by a |clone| with the appropriate number of
zeros.
%
\lstset{firstnumber=last}
\begin{ecode}
  let padZero l1 l2 =
    let n = List.length l1 - List.length l2 in
    if n < 0 then
      (clone 0 ((-1) * n) @ l2, l2)
    else
      (l1, _=clone 0 n=___ :: l2__)
\end{ecode}
\lstset{firstnumber=1}
%
Alas, our student has accidentally used the |::| operator rather than
the |@| operator in the |else| branch.
%
\sherrloc and \ocaml correctly determine that she cannot cons the
|int list| returned by |clone| onto |l2|, which is another |int list|,
but they decide to \emph{blame} the call to |clone|, while our Decision
Tree correctly blames the |::| operator.
%
\ES{TODO: WHY? (might be too similar to previous?)}


% ES: decision tree gets this one wrong, may want to find something else
% \begin{ecode}
%   let rec sepConcat sep sl =
%     match sl with
%     | [] -> ""
%     | h::t ->
%         let f a x = a ^ (sep ^ x) in
%         List.fold_left f h t

%   let stringOfList f l = sepConcat "; " __[ "["; ___=List.map f l=___; "]" ]__
% \end{ecode}

\paragraph{Computing the Fixed Point of a Function}
% data/sp14/0941.ml
Finally, our students must write a |fixpoint| function that computes the
fixed point of a given function |f|, starting from an initial value |b|.
%
As a hint we first have them write a |wwhile| function that performs the
functional equivalent of a \texttt{while}-loop, repeatedly passing a function's
output back in until it receives a (boolean) signal to stop.
%
\begin{ecode}
  let rec wwhile (f, b) =
    match f b with
    | (x, false) -> x
    | (x, true)  -> wwhile (f, x)
\end{ecode}
\lstset{firstnumber=last}
%
The |fixpoint| function can then be written as a clever instantiation of
the arguments to |wwhile|.
%
\begin{ecode}
  let fixpoint (f, b) =
    let g = __let bb = f b in ___=(bb, (bb = b))=_ in
    wwhile (g, b)
\end{ecode}
\lstset{firstnumber=1}
%
Sadly, our student has forgotten that |g| should itself be a function.
%
As a result, she passes a pair of a \emph{pair} and a starting value to
|wwhile|, rather than a pair of a \emph{function} and a starting value.
%
\sherrloc deduces that the call to |wwhile| is likely correct (\ocaml
actually blames the use of |g|), but identifies the construction of the
pair inside |g| as the most likely culprit, while our Decision Tree
correctly identifies the \emph{definition} of |g| as the source of the
error.
\ES{TODO: WHY?}


\subsubsection{Failed Predictions}
\label{sec:failed-predictions}
Of course, our classifiers are sometimes wrong, we focus next on programs
where our classifier makes an incorrect prediction.

\paragraph{Constructing a List of Duplicates}
% data/sp14/0148.ml
Consider the following implementation of the |clone| function from
before.
%
\begin{ecode}
  let rec clone x n =
    let loop acc n =
      if n <= 0 then
        acc
      else
        clone ==([==_=x=_==] @ acc)== (n - 1) in
    loop [] n
\end{ecode}
% \ES{TODO: our 2nd prediction matches \sherrloc and \ocaml (occurs check), correct fix is to replace recursive call to clone with loop}
%
The student has defined a helper function |loop| with an accumulator
|acc|, likely meant to call itself tail-recursively.
%
Unfortunately, she has called the top-level function |clone| rather than
|loop| in the |else| branch, this induces a cyclic constraint |'a = 'a list|
for the |x| argument to |clone|.

Our classifier incorrectly predicts that the use of |x| in the recursive
call is the most likely source of the error.
\ES{TOOD: WHY??}
%
Our second prediction coincides with \sherrloc (and \ocaml), blaming the
the first argument to |clone|.
%
This is also incorrect, but may be more helpful than our first
prediction --- if our student decides that she has certainly provided
the correct \emph{argument}, an alternative explanation is that
perhaps she has called the wrong \emph{function}.
%
Our final prediction is the entire body of |clone|, which is hardly
helpful.

\paragraph{Currying Considered Harmful?}
% data/sp14/0887.ml
Our next example is another ill-fated attempt at |clone|.
%
\begin{ecode}
  let rec clone x n =
    let rec loop x n acc =
      if n < 0 then
        acc
      else
        ==loop== __(x, (n - 1), (x :: acc))__ in
    loop (x, n, [])
\end{ecode}
The issue here is that \ocaml functions are \emph{curried} by default
--- \ie they take their arguments one at a time --- but our student has
called the inner |loop| with all three arguments in a tuple.
%
Many experienced functional programmers would choose to keep |loop|
curried and rewrite the calls, however our student decides instead to
\emph{uncurry} |loop|, making it take a tuple of arguments.
%
\sherrloc blames the recursive call to |loop| while our classifier
blames the tuple of arguments --- a reasonable suggestion, but alas not
the answer the student was looking for.
\ES{WHY??}
%

\paragraph{Composing Functions}
% data/sp14/2269.ml
Next, let us consider the |pipe| function that composes a list of
functions, \ie given a list of functions |[f;g;h]|, |pipe| produces the
function |fun x -> h (g (f x))|.
%
\begin{ecode}
  let pipe fs =
    let f a x y = ==y== __(a y)__ in
    let base x = x in
    List.fold_left f base fs
\end{ecode}
%
The error in our student's code is that she has applied |y| rather than
|x| to the result of |a y|.
%
\sherrloc correctly blames the first occurrence of |y|, while our
classifier (incorrectly) blames the application |a y| (\ocaml blames
the occurrence of |base| on line 4).
%
\ES{TODO: WHY?}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
